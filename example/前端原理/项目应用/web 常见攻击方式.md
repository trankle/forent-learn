<!--
 * @Description:  
 * @Author: 王天琦
 * @Date: 2023-10-25 17:12:05
-->
# 加密方式
## Hash 散列 算法
var SHA256 = require("crypto-js/sha256");
console.log(SHA256("Message"));

var hash = md5("Hello World"); // b10a8db164e0754105b7a99be72e3fe5
# web 常见攻击方式
XSS 跨站脚本攻击[侧重于脚本，千方百计的注入并执行恶意脚本]
CSRF 跨站请求伪造[不注入恶意脚本，侧重于请求伪造借刀杀人，在用户不知情的情况下，借用户的名义干坏事]
SQL注入[表单提交携带恶意sql语句]
## XSS 跨站脚本攻击 攻击者在受害者的网站*注入脚本*执行操作
[url 参数注入 、输入框注入]
[反射型、存储型、DOM 型]
- 反射型:通过 URL 传递参数，诱导用户主动打开恶意URL,服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器，恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为。
常见于通过 URL 传递参数的功能，如网站搜索、跳转。
- 存储型:攻击者将恶意代码提交到目标网站的数据库,用户请求到恶意代码后执行。对所有用户有效果。
用户保存数据的网站功能，如论坛发帖、商品评论、用户私信。
- DOM型(浏览器端):用户打开带有恶意代码的 URL,浏览器接收到响应后解析执行代码。
DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞
### 预防
对输入进行过滤，对执行进行转义;
cookie设置httponly;
## CSRF 跨站请求伪造
不注入脚本，侧重于*请求伪造*，在用户不知道情况下，伪造请求，引诱用户操作链接。
后端服务器只是对 cookie 验证，没有其他验证，所以预防就只有在服务端，无法通过客户端预防。
### 预防
- 不要用 cookie 方式，而是 jwt 方式，登录成功后，服务端给客户端一个 token放在request.header 的 Authorization。
- 尽量使用 post。
- 加入随机验证码。
- 设置token,验证 referer，记录当前地址的来源地址，浏览器发送端无法伪造(document.referer 是真实的)，但是服务器端截获后可以伪造(req.header 中拿到的不一定真实)。
- cookie 设置了 httpOnly
## SQL注入 针对数据库
表单提交携带恶意sql语句
### 预防
- 参数化：也就是让数据库知道哪些是查询，哪些是数据，从而避免混乱。这通常是通过预先定义SQL语句，然后将用户输入作为参数参数查询参数The userpart of the query is a parameter, and the user input is passed as a parameterplace-holder来实现的。这样可以确保用户输入不会被解析为SQL代码。
- 输入验证：检查用户输入的所有数据，以确保它们符合预期的格式。例如，如果期望的是一个日期，那么任何非日期的输入都应该被拒绝。
- 使用Web应用DDoS保护：例如，使用Web应用防火墙(rs:是或否)来保护你的应用程序免受SQL注入攻击。
